!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/bart/Developer/42/ft_irc/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
${NAME}	Makefile	/^${NAME}:	${OBJS}$/;"	t
%.o	Makefile	/^%.o: %.cpp$/;"	t
AlreadyJoined	channel/Channel.hpp	/^		struct AlreadyJoined: std::exception {$/;"	s	class:Channel
BUFFER_SIZE	server/Server.hpp	/^#define BUFFER_SIZE /;"	d
CHANNEL_DATA_HPP	data/ChannelData.hpp	/^# define CHANNEL_DATA_HPP$/;"	d
CHANNEL_HPP	channel/Channel.hpp	/^# define CHANNEL_HPP$/;"	d
CMD_STRINGIFY	message/Message.cpp	/^# define CMD_STRINGIFY(/;"	d	file:
COMMAND_HPP	message/Message.hpp	/^# define COMMAND_HPP$/;"	d
CXXFLAGS	Makefile	/^CXXFLAGS = -Wall -Wextra -Werror -std=c++98 -g$/;"	m
Channel	channel/Channel.cpp	/^Channel::Channel(): operator_user(NULL) {}$/;"	f	class:Channel
Channel	channel/Channel.cpp	/^Channel::Channel(const Channel& other) {$/;"	f	class:Channel
Channel	channel/Channel.cpp	/^Channel::Channel(const string& name, const User& operator_user)$/;"	f	class:Channel
Channel	channel/Channel.hpp	/^class Channel {$/;"	c
ChannelAlreadyExist	data/ChannelData.hpp	/^		struct ChannelAlreadyExist: public std::exception {$/;"	s	class:ChannelData
ChannelData	data/ChannelData.cpp	/^ChannelData::ChannelData() {}$/;"	f	class:ChannelData
ChannelData	data/ChannelData.hpp	/^class ChannelData{$/;"	c
ChannelNotExist	data/ChannelData.hpp	/^		struct ChannelNotExist: public std::exception { $/;"	s	class:ChannelData
Command	message/Message.cpp	/^Command::Command() {}$/;"	f	class:Command
Command	message/Message.cpp	/^Command::Command(const string& str) {$/;"	f	class:Command
Command	message/Message.hpp	/^struct Command {$/;"	s
Connection	user/User.cpp	/^Connection::Connection(): is_alive(false) {}$/;"	f	class:Connection
Connection	user/User.cpp	/^Connection::Connection(const struct sockaddr_storage* addr, const int socket_fd): is_alive(false/;"	f	class:Connection
Connection	user/User.hpp	/^struct Connection {$/;"	s
FB_DEFAULT	include/common.hpp	/^#define FB_DEFAULT /;"	d
FT_IRC_INCLUDE_COMMON_HPP_	include/common.hpp	/^#define FT_IRC_INCLUDE_COMMON_HPP_$/;"	d
FT_IRC_SERVER_INITIALIZE_HPP_	server/Server.hpp	/^#define FT_IRC_SERVER_INITIALIZE_HPP_$/;"	d
FT_IRC__DEBUG_HPP_	include/debug.hpp	/^#define FT_IRC__DEBUG_HPP_$/;"	d
FT_IRC__UTILS_HPP_	include/utils.hpp	/^#define FT_IRC__UTILS_HPP_$/;"	d
F_BLACK	include/common.hpp	/^#define F_BLACK /;"	d
F_BLUE	include/common.hpp	/^#define F_BLUE /;"	d
F_CYAN	include/common.hpp	/^#define F_CYAN /;"	d
F_GREEN	include/common.hpp	/^#define F_GREEN /;"	d
F_MAGENTA	include/common.hpp	/^#define F_MAGENTA /;"	d
F_RED	include/common.hpp	/^#define F_RED /;"	d
F_WHITE	include/common.hpp	/^#define F_WHITE /;"	d
F_YELLOW	include/common.hpp	/^#define F_YELLOW /;"	d
INCLUDE	Makefile	/^INCLUDE = -I include -I include\/server$/;"	m
INVITE	message/Message.hpp	/^		INVITE,$/;"	e	enum:Command::Type
MAX_CLIENT_NUM	server/Server.hpp	/^#define MAX_CLIENT_NUM /;"	d
MODE	message/Message.hpp	/^		MODE$/;"	e	enum:Command::Type
MacOS에만 해당하는 사항	README.md	/^### MacOS에만 해당하는 사항$/;"	S	section:ft_irc""필수 파트
Message	message/Message.cpp	/^Message::Message(const std::string& str): params(vector<string>()) {$/;"	f	class:Message
Message	message/Message.hpp	/^struct Message {$/;"	s
NAME	Makefile	/^NAME = ft_irc$/;"	m
NICK	message/Message.hpp	/^		NICK = 0,$/;"	e	enum:Command::Type
NoPermission	channel/Channel.hpp	/^		struct NoPermission: std::exception {$/;"	s	class:Channel
OBJS	Makefile	/^OBJS = ${SRCS:.cpp=.o}$/;"	m
ParsingFail	message/Message.hpp	/^	struct ParsingFail: public std::exception {$/;"	s	struct:Message
RM	Makefile	/^RM = rm -f$/;"	m
SRCS	Makefile	/^SRCS = main.cpp \\$/;"	m
Server	server/Server.cpp	/^Server::Server() {$/;"	f	class:Server
Server	server/Server.cpp	/^Server::Server(const Server &server) {$/;"	f	class:Server
Server	server/Server.hpp	/^class Server {$/;"	c
TIMEOUT_SEC	server/Server.hpp	/^#define TIMEOUT_SEC /;"	d
TOPIC	message/Message.hpp	/^		TOPIC,$/;"	e	enum:Command::Type
Type	message/Message.hpp	/^	enum Type{$/;"	g	struct:Command
USER_DATA_HPP	data/UserData.hpp	/^# define USER_DATA_HPP$/;"	d
USER_HPP	user/User.hpp	/^# define USER_HPP$/;"	d
UnSupported	message/Message.hpp	/^	struct UnSupported: public std::exception {$/;"	s	struct:Command
User	user/User.cpp	/^User::User() { }$/;"	f	class:User
User	user/User.cpp	/^User::User(const Connection connection, const string& nick)$/;"	f	class:User
User	user/User.cpp	/^User::User(const User& other):$/;"	f	class:User
User	user/User.hpp	/^class User {$/;"	c
UserAlreadyExist	data/UserData.hpp	/^	struct UserAlreadyExist: public std::exception {$/;"	s	class:UserData
UserData	data/UserData.cpp	/^UserData::UserData() {}$/;"	f	class:UserData
UserData	data/UserData.hpp	/^class UserData {$/;"	c
UserNotExist	data/UserData.hpp	/^	struct UserNotExist: public std::exception {$/;"	s	class:UserData
V4	user/User.hpp	/^		V4,$/;"	e	enum:Connection::__anon77e66f480103
V6	user/User.hpp	/^		V6$/;"	e	enum:Connection::__anon77e66f480103
__anon77e66f480103	user/User.hpp	/^	enum {$/;"	g	struct:Connection
_client_fds	server/Server.hpp	/^  fd_set _client_fds;$/;"	m	class:Server	typeref:typename:fd_set
_fd_max	server/Server.hpp	/^  int _fd_max;$/;"	m	class:Server	typeref:typename:int
_is_debug	server/Server.hpp	/^  bool _is_debug;$/;"	m	class:Server	typeref:typename:bool
_max_client_number	server/Server.hpp	/^  int _max_client_number;$/;"	m	class:Server	typeref:typename:int
_server_addr	server/Server.hpp	/^  struct sockaddr_in _server_addr;$/;"	m	class:Server	typeref:struct:sockaddr_in
_server_socket	server/Server.hpp	/^  int _server_socket;$/;"	m	class:Server	typeref:typename:int
acceptClient	server/Server.cpp	/^void Server::acceptClient() {$/;"	f	class:Server	typeref:typename:void
add_channel	user/User.cpp	/^void User::add_channel(const Channel& channel) {$/;"	f	class:User	typeref:typename:void
add_user	channel/Channel.cpp	/^void Channel::add_user(const User& user) {$/;"	f	class:Channel	typeref:typename:void
add_user	data/UserData.cpp	/^void UserData::add_user(const User& user) {$/;"	f	class:UserData	typeref:typename:void
address	user/User.hpp	/^	std::string address;$/;"	m	struct:Connection	typeref:typename:std::string
all	Makefile	/^all:	${NAME}$/;"	t
all_commands	message/Message.cpp	/^const char *all_commands[] = {$/;"	v	typeref:typename:const char * []
channel_map	data/ChannelData.hpp	/^		std::map<std::string, std::list<Channel>::iterator> channel_map;$/;"	m	class:ChannelData	typeref:typename:std::map<std::string,std::list<Channel>::iterator>
channels	data/ChannelData.hpp	/^		std::list<Channel> channels;$/;"	m	class:ChannelData	typeref:typename:std::list<Channel>
clean	Makefile	/^clean:$/;"	t
closeClient	server/Server.cpp	/^void Server::closeClient(int client_socket) {$/;"	f	class:Server	typeref:typename:void
closeServer	server/Server.cpp	/^void Server::closeServer() {$/;"	f	class:Server	typeref:typename:void
command	message/Message.hpp	/^	Command command;$/;"	m	struct:Message	typeref:typename:Command
connection	user/User.hpp	/^		Connection connection;$/;"	m	class:User	typeref:typename:Connection
create_channel	data/ChannelData.cpp	/^void ChannelData::create_channel(const string& name, const User& user) {$/;"	f	class:ChannelData	typeref:typename:void
delete_user	data/UserData.cpp	/^void UserData::delete_user(const User& user) {$/;"	f	class:UserData	typeref:typename:void
fclean	Makefile	/^fclean:	clean$/;"	t
ft_irc	README.md	/^# ft_irc$/;"	c
getClientFds	server/Server.cpp	/^fd_set Server::getClientFds() const {$/;"	f	class:Server	typeref:typename:fd_set
getFdMax	server/Server.cpp	/^int Server::getFdMax() const {$/;"	f	class:Server	typeref:typename:int
getIsDebug	server/Server.cpp	/^bool Server::getIsDebug() const {$/;"	f	class:Server	typeref:typename:bool
getMaxClientNumber	server/Server.cpp	/^int Server::getMaxClientNumber() const {$/;"	f	class:Server	typeref:typename:int
getPortInDebugMode	debug/debug.cpp	/^std::string getPortInDebugMode() {$/;"	f	typeref:typename:std::string
getServerAddr	server/Server.cpp	/^struct sockaddr_in Server::getServerAddr() const {$/;"	f	class:Server	typeref:struct:sockaddr_in
getServerSocket	server/Server.cpp	/^int Server::getServerSocket() const {$/;"	f	class:Server	typeref:typename:int
get_all_channels	user/User.cpp	/^vector<const Channel*> User::get_all_channels() const {$/;"	f	class:User	typeref:typename:vector<const Channel * >
get_channel	data/ChannelData.cpp	/^Channel& ChannelData::get_channel(const string& name) const {$/;"	f	class:ChannelData	typeref:typename:Channel &
get_hostname	user/User.cpp	/^const string& User::get_hostname() const {$/;"	f	class:User	typeref:typename:const string &
get_in_addr	utils/socket_utils.cpp	/^void* get_in_addr(const struct sockaddr* sa)$/;"	f	typeref:typename:void *
get_name	channel/Channel.cpp	/^const string& Channel::get_name() const {$/;"	f	class:Channel	typeref:typename:const string &
get_nickname	user/User.cpp	/^const string& User::get_nickname() const {$/;"	f	class:User	typeref:typename:const string &
get_operator	channel/Channel.cpp	/^const User& Channel::get_operator() const {$/;"	f	class:Channel	typeref:typename:const User &
get_storage	data/ChannelData.cpp	/^ChannelData& ChannelData::get_storage() {$/;"	f	class:ChannelData	typeref:typename:ChannelData &
get_storage	data/UserData.cpp	/^UserData& UserData::get_storage() {$/;"	f	class:UserData	typeref:typename:UserData &
get_topic	channel/Channel.cpp	/^const string& Channel::get_topic() const {$/;"	f	class:Channel	typeref:typename:const string &
get_user	data/UserData.cpp	/^User& UserData::get_user(const string& nickname) const {$/;"	f	class:UserData	typeref:typename:User &
get_user_names	channel/Channel.cpp	/^vector<string> Channel::get_user_names() const {$/;"	f	class:Channel	typeref:typename:vector<string>
get_users	channel/Channel.cpp	/^vector<const User*> Channel::get_users() const {$/;"	f	class:Channel	typeref:typename:vector<const User * >
hostname	user/User.hpp	/^		std::string hostname;$/;"	m	class:User	typeref:typename:std::string
initializeClientFds	server/Server.cpp	/^void Server::initializeClientFds() {$/;"	f	class:Server	typeref:typename:void
initializeServer	server/Server.cpp	/^void Server::initializeServer(const char *port) {$/;"	f	class:Server	typeref:typename:void
ip_family	user/User.hpp	/^	} ip_family;$/;"	m	struct:Connection	typeref:enum:Connection::__anon77e66f480103
isNumber	utils/utils.cpp	/^bool isNumber(const char *str) {$/;"	f	typeref:typename:bool
isValidPort	utils/utils.cpp	/^bool isValidPort(const char *port) {$/;"	f	typeref:typename:bool
is_alive	user/User.hpp	/^	bool is_alive;$/;"	m	struct:Connection	typeref:typename:bool
is_available	user/User.cpp	/^bool User::is_available() const {$/;"	f	class:User	typeref:typename:bool
is_channel_exist	data/ChannelData.cpp	/^bool ChannelData::is_channel_exist(const string& name) const {$/;"	f	class:ChannelData	typeref:typename:bool
is_joined	user/User.cpp	/^bool User::is_joined(const string& channel_name) const {$/;"	f	class:User	typeref:typename:bool
is_user_exist	data/UserData.cpp	/^bool UserData::is_user_exist(const string& nickname) const {$/;"	f	class:UserData	typeref:typename:bool
join_channel	data/ChannelData.cpp	/^void ChannelData::join_channel(const string& name, const User& user) {$/;"	f	class:ChannelData	typeref:typename:void
joined_channels	user/User.hpp	/^		std::vector<const Channel*> joined_channels;$/;"	m	class:User	typeref:typename:std::vector<const Channel * >
leave_channel	data/ChannelData.cpp	/^void ChannelData::leave_channel(const Channel &channel, const User& user) {$/;"	f	class:ChannelData	typeref:typename:void
main	main.cpp	/^int main(int argc, char *argv[]) {$/;"	f	typeref:typename:int
name	channel/Channel.hpp	/^		std::string name;$/;"	m	class:Channel	typeref:typename:std::string
nickname	user/User.hpp	/^		std::string nickname;$/;"	m	class:User	typeref:typename:std::string
operator <<	server/Server.cpp	/^std::ostream &operator<<(std::ostream &os, const Server &server) {$/;"	f	typeref:typename:std::ostream &
operator <<	server/Server.cpp	/^std::ostream &operator<<(std::ostream &os, const fd_set &client_fds) {$/;"	f	typeref:typename:std::ostream &
operator =	channel/Channel.cpp	/^Channel& Channel::operator=(const Channel& other) {$/;"	f	class:Channel	typeref:typename:Channel &
operator =	server/Server.cpp	/^Server &Server::operator=(const Server &server) {$/;"	f	class:Server	typeref:typename:Server &
operator =	user/User.cpp	/^User& User::operator=(const User& other) {$/;"	f	class:User	typeref:typename:User &
operator ==	channel/Channel.cpp	/^bool Channel::operator==(const Channel& other) const {$/;"	f	class:Channel	typeref:typename:bool
operator ==	channel/Channel.cpp	/^bool operator==(const Channel& a, const Channel& b) {$/;"	f	typeref:typename:bool
operator ==	user/User.cpp	/^bool Connection::operator==(const Connection& other) const {$/;"	f	class:Connection	typeref:typename:bool
operator ==	user/User.cpp	/^bool User::operator==(const User& other) const {$/;"	f	class:User	typeref:typename:bool
operator ==	user/User.cpp	/^bool operator==(const Connection& a, const Connection& b) {$/;"	f	typeref:typename:bool
operator ==	user/User.cpp	/^bool operator==(const User& a, const User& b) {$/;"	f	typeref:typename:bool
operator_user	channel/Channel.hpp	/^		const User* operator_user;$/;"	m	class:Channel	typeref:typename:const User *
params	message/Message.hpp	/^	std::vector<std::string> params;$/;"	m	struct:Message	typeref:typename:std::vector<std::string>
port	user/User.hpp	/^	int port;$/;"	m	struct:Connection	typeref:typename:int
prefix	message/Message.hpp	/^	std::string prefix;$/;"	m	struct:Message	typeref:typename:std::string
printError	utils/utils.cpp	/^void printError(std::string message) {$/;"	f	typeref:typename:void
re	Makefile	/^re:		fclean all$/;"	t
receiveMessage	server/Server.cpp	/^char *Server::receiveMessage(int client_socket) {$/;"	f	class:Server	typeref:typename:char *
remove_channel	data/ChannelData.cpp	/^void ChannelData::remove_channel(const Channel& channel) {$/;"	f	class:ChannelData	typeref:typename:void
remove_channel	user/User.cpp	/^void User::remove_channel(const Channel& channel) {$/;"	f	class:User	typeref:typename:void
remove_channel	user/User.cpp	/^void User::remove_channel(const string& name) {$/;"	f	class:User	typeref:typename:void
remove_user	channel/Channel.cpp	/^void Channel::remove_user(const User& user) {$/;"	f	class:Channel	typeref:typename:void
runServer	server/Server.cpp	/^void Server::runServer() {$/;"	f	class:Server	typeref:typename:void
sendMessage	server/Server.cpp	/^void Server::sendMessage(int client_socket, char *message) {$/;"	f	class:Server	typeref:typename:void
setClientFds	server/Server.cpp	/^void Server::setClientFds(fd_set client_fds) {$/;"	f	class:Server	typeref:typename:void
setFdMax	server/Server.cpp	/^void Server::setFdMax(int fd_max) {$/;"	f	class:Server	typeref:typename:void
setIsDebug	server/Server.cpp	/^void Server::setIsDebug(bool is_debug) {$/;"	f	class:Server	typeref:typename:void
setMaxClientNumber	server/Server.cpp	/^void Server::setMaxClientNumber(int max_client_number) {$/;"	f	class:Server	typeref:typename:void
setServerAddr	server/Server.cpp	/^void Server::setServerAddr(struct sockaddr_in server_addr) {$/;"	f	class:Server	typeref:typename:void
setServerSocket	server/Server.cpp	/^void Server::setServerSocket(int server_socket) {$/;"	f	class:Server	typeref:typename:void
socket_fd	user/User.hpp	/^	int socket_fd;$/;"	m	struct:Connection	typeref:typename:int
split_string	utils/string_utils.cpp	/^vector<string> split_string(const string& str) {$/;"	f	typeref:typename:vector<string>
str_iter	utils/string_utils.cpp	/^typedef std::istream_iterator<string> str_iter;$/;"	t	typeref:typename:std::istream_iterator<string>	file:
topic	channel/Channel.hpp	/^		std::string topic;$/;"	m	class:Channel	typeref:typename:std::string
type	message/Message.hpp	/^	} type;$/;"	m	struct:Command	typeref:enum:Command::Type
type_string	message/Message.cpp	/^string Command::type_string() const {$/;"	f	class:Command	typeref:typename:string
user_nick_map	data/UserData.hpp	/^		std::map<std::string, std::list<User>::iterator> user_nick_map;$/;"	m	class:UserData	typeref:typename:std::map<std::string,std::list<User>::iterator>
users	channel/Channel.hpp	/^		std::vector<const User*> users;$/;"	m	class:Channel	typeref:typename:std::vector<const User * >
users	data/UserData.hpp	/^		std::list<User> users;$/;"	m	class:UserData	typeref:typename:std::list<User>
what	channel/Channel.cpp	/^const char* Channel::AlreadyJoined::what() {$/;"	f	class:Channel::AlreadyJoined	typeref:typename:const char *
what	channel/Channel.cpp	/^const char* Channel::NoPermission::what() {$/;"	f	class:Channel::NoPermission	typeref:typename:const char *
what	data/ChannelData.cpp	/^const char* ChannelData::ChannelAlreadyExist::what() {$/;"	f	class:ChannelData::ChannelAlreadyExist	typeref:typename:const char *
what	data/ChannelData.cpp	/^const char* ChannelData::ChannelNotExist::what() {$/;"	f	class:ChannelData::ChannelNotExist	typeref:typename:const char *
what	data/UserData.cpp	/^const char* UserData::UserAlreadyExist::what() {$/;"	f	class:UserData::UserAlreadyExist	typeref:typename:const char *
what	data/UserData.cpp	/^const char* UserData::UserNotExist::what() {$/;"	f	class:UserData::UserNotExist	typeref:typename:const char *
what	message/Message.cpp	/^const char* Command::UnSupported::what() {$/;"	f	class:Command::UnSupported	typeref:typename:const char *
what	message/Message.cpp	/^const char* Message::ParsingFail::what() {$/;"	f	class:Message::ParsingFail	typeref:typename:const char *
~Channel	channel/Channel.cpp	/^Channel::~Channel() { }$/;"	f	class:Channel
~ChannelData	data/ChannelData.cpp	/^ChannelData::~ChannelData() {$/;"	f	class:ChannelData
~Server	server/Server.cpp	/^Server::~Server() {$/;"	f	class:Server
~User	user/User.cpp	/^User::~User() { }$/;"	f	class:User
~UserData	data/UserData.cpp	/^UserData::~UserData() {$/;"	f	class:UserData
개요	.github/ISSUE_TEMPLATE/bug.md	/^## 개요$/;"	s
개요	.github/ISSUE_TEMPLATE/chore.md	/^## 개요$/;"	s
개요	.github/ISSUE_TEMPLATE/feat.md	/^## 개요$/;"	s
변경점	pull_request_template.md	/^## 변경점$/;"	s
보너스 파트	README.md	/^## 보너스 파트$/;"	s	chapter:ft_irc
비고	.github/ISSUE_TEMPLATE/bug.md	/^## 비고$/;"	s
스크린샷(선택)	.github/ISSUE_TEMPLATE/bug.md	/^## 스크린샷(선택)$/;"	s
스크린샷(선택)	pull_request_template.md	/^## 스크린샷(선택)$/;"	s
요구사항	README.md	/^### 요구사항$/;"	S	section:ft_irc""필수 파트
원하는 동작	.github/ISSUE_TEMPLATE/bug.md	/^## 원하는 동작$/;"	s
작업 내용	.github/ISSUE_TEMPLATE/feat.md	/^## 작업 내용$/;"	s
재현 방법	.github/ISSUE_TEMPLATE/bug.md	/^## 재현 방법$/;"	s
점검	pull_request_template.md	/^## 점검$/;"	s
테스트 내용 (선택)	pull_request_template.md	/^## 테스트 내용 (선택)$/;"	s
테스트 예시	README.md	/^### 테스트 예시$/;"	S	section:ft_irc""필수 파트
필수 파트	README.md	/^## 필수 파트$/;"	s	chapter:ft_irc
